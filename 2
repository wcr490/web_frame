use super::*;

type MidwareExe = Box<dyn Middleware>;
pub struct Midware(pub MidwareExe, pub RequestType);

pub enum Midware {
    Get(MidwareExe, RequestType),
}

pub struct MQueue {
    inner: VecDeque<Midware>,
    is_boot: bool,
}
pub enum Priority {
    Unknown,
    P1,
    P2,
    P3,
}
pub trait Middleware {
    fn exe(&self, req: RequestType) -> RequestType;
    fn priority(&self) -> Priority;
}

impl MQueue {
    pub fn new() -> Self {
        MQueue {
            inner: VecDeque::new(),
            is_boot: false,
        }
    }
    pub fn boot(&mut self, req: RequestType) -> bool {
        if let Some(head) = self.peek_mut() {
            head.1 = req;
            self.is_boot = true;
        }
        self.dequeue()
    }
    pub fn enqueue(&mut self, item: Midware) {
        self.inner.push_back(item);
    }
    pub fn dequeue(&mut self) -> bool {
        if self.is_boot {
            if let Some(cur_midware) = self.inner.pop_front() {
                if let Some(next_midware) = self.peek_mut() {
                    next_midware.1 = cur_midware.0.exe(cur_midware.1);
                    return true;
                }
                self.is_boot = false;
                return true;
            }
            return false;
        }
        false
    }
    pub fn peek_mut(&mut self) -> Option<&mut Midware> {
        self.inner.front_mut()
    }
    pub fn peek(&self) -> Option<&Midware> {
        self.inner.front()
    }
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
    pub fn len(&self) -> usize {
        self.inner.len()
    }
}
